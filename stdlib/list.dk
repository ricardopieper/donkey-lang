struct List<T>:
    buf: ptr<T>
    len: u64
    cap: u64

# Creates a new list
def list_new<T>() -> List<T>:
    list = List<T>()
    list.len = 0
    list.cap = 0

    return list


struct ListIterator<T>:
    list: ptr<List<T>>
    current: u64

impl List<T>:

    def len(self) -> u64:
        return (*self).len

    def __index_ptr__(self, index: u64) -> ptr<T>:
        return &(*self).buf[index]

    def add(self, item: T):
        len = (*self).len
        cap = (*self).cap
        print("reached 1")
        if len == cap:
            print("reached 2")
            if len == 0:
                print("reached 3")
                (*self).cap = 4
            else:
                (*self).cap = cap * 2
            print("allocating... 4")
            new_allocation = mem_alloc<T>((*self).cap)
            print("allocated 5")

            if len > 0:
                print("reached 6")
                i: u64 = 0
                while i < len:
                    new_allocation[i] = (*self).buf[i]
                    i = i + 1
                mem_free<T>((*self).buf)
            print("reached 7")
            (*self).buf = new_allocation
            print("reached 8")
        print("reached 9")
        (*self).buf[len] = item
        print("reached 10")
        (*self).len = len + 1

    def get(self, index: u64) -> T:
        return (*self).buf[index]

    def __iterator__(self) -> ListIterator<T>:
        iterator = ListIterator<T>()
        iterator.list = self
        iterator.current = 0
        return iterator

impl ListIterator<T>:

    def __has_next__(self) -> bool:
        return (*self).current < (*(*self).list).len

    def __next__(self):
        self_deref = *self
        ls = self_deref.list
        next = (*ls).__index_ptr__(0)
